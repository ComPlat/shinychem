[{"name":"app.R","content":"library(shiny)\nlibrary(DT)\nlibrary(bslib)\nlibrary(broom)\nlibrary(utils)\nlibrary(ggplot2)\nlibrary(base64enc)\nlibrary(shinyjs)\nlibrary(mgcv)\nlibrary(RColorBrewer)\n\nsource(\"check_ast.R\")\nsource(\"utils.R\")\nsource(\"plottingInternally.R\")\nsource(\"correlation.R\")\nsource(\"visualisation.R\")\n\nui <- fluidPage(\n  useShinyjs(),\n  sidebarLayout(\n    sidebarPanel(\n      conditionalPanel(\n        condition = \"input.conditionedPanels == 'Data'\",\n        fileInput(\"file\", \"Choose CSV File\",\n                  accept = c(\"text/csv\",\n                             \"text/comma-separated-values,text/plain\",\n                             \".csv\")\n        ),\n        textInput(\"op\", \"Operations\", value = \"var / 1000\"),\n        textInput(\"new_col\", \"Name of new variable\", value = \"var\"),\n        actionButton(\"mod\", \"Modify\"),\n        verbatimTextOutput(\"mod_error\"),\n        tags$hr(),\n        helpText(\"Please upload a CSV file.\")\n      ),\n      conditionalPanel(\n        condition = \"input.conditionedPanels == 'Correlation'\",\n        corrSidebarUI(\"CORR\")\n      ),\n      conditionalPanel(\n        condition = \"input.conditionedPanels == 'Visualisation'\",\n        visSidebarUI(\"VIS\")\n      )\n    ),  \n    \n    mainPanel(\n      tabsetPanel(\n        tabPanel(\"Data\",\n            DTOutput(\"df\")\n        ),\n        \n        tabPanel(\"Correlation\",\n            corrUI(\"CORR\")\n        ),\n        \n        tabPanel(\"Visualisation\",\n            visUI(\"VIS\")\n        ),\n        \n        id = \"conditionedPanels\"   \n      )\n    )\n    \n  )\n)\n\nserver <- function(input, output) {\n  dataSet <- reactiveValues(df = NULL)\n\n  output$df <- renderDT({\n    req(input$file)\n    df <- try(read.csv(input$file$datapath))\n    if (inherits(df, \"try-error\")) {\n      err <- conditionMessage(attr(e, \"condition\"))\n      showNotification(err)\n      return(NULL)\n    } \n    dataSet$df <- df\n    req(!is.na(dataSet$df))\n    datatable(dataSet$df, options = list(pageLength = 10)) \n  })\n\n  observeEvent(input$mod, {\n    req(!is.null(dataSet$df))\n    req(is.data.frame(dataSet$df))\n    req(input$op)\n    req(input$new_col)\n    dt <- dataSet$df\n    op <- input$op\n    new_col <- input$new_col\n    new <- NULL\n    err <- NULL\n    e <- try({\n      ast <- get_ast(str2lang(op))\n      ast <- ast[[length(ast)]]\n    })\n    if (e == \"Error\") {\n      showNotification(\"Found unallowed function\")\n      return()\n    } else if (inherits(e, \"try-error\")) {\n      showNotification(e)\n      return()\n    }\n    e <- try(\n      new <- with(dt, eval(parse(text = op)))\n    )\n    if (inherits(e, \"try-error\")) {\n      err <- conditionMessage(attr(e, \"condition\"))\n    } else {\n      dataSet$df[, new_col] <- new\n    }\n    output$df <- renderDT(dataSet$df)\n    output$mod_error <- renderText(err)  \n    return(df)\n  })\n  \n  listResults <- reactiveValues(curr_data = NULL, curr_name = NULL,\n                                all_data = list(), all_names = list())\n  corrServer(\"CORR\", dataSet, listResults)\n  visServer(\"VIS\", dataSet, listResults)\n  \n}\n\nshinyApp(ui, server)","type":"text"},{"name":"BiostatsGithubPage.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n","type":"text"},{"name":"check_ast.R","content":"get_ast <- function(inp) {\n  if (!is.call(inp)) {\n    return(inp)\n  }\n\n  inp <- as.list(inp)\n\n  # check if is function\n  fct <- inp[[1]]\n\n  allowed_fcts <- c(\n    \"-\", \"+\", \"*\", \"/\",\n    \"log\", \"log10\", \"sqrt\", \"exp\", \"^\",\n    \"sin\", \"cos\", \"tan\", \"tanh\", \"sinh\", \"cosh\", \"acos\", \"asin\", \"atan\",\n    \"is.numeric\", \"is.character\", \"is.logical\", \"is.factor\", \"is.integer\",\n    \"as.numeric\", \"as.character\", \"as.logical\", \"as.factor\", \"as.integer\",\n    \">\", \"<\", \"<=\", \">=\", \"==\", \"!=\",\n    \"abs\", \"ceiling\", \"floor\", \"trunc\", \"round\",\n    \"grep\", \"substr\", \"sub\", \"paste\", \"paste0\",\n    \"strsplit\", \"tolower\", \"toupper\",\n    \"dnorm\", \"pnorm\", \"qnorm\", \"rnorm\", \"dbinom\",\n    \"pbinom\", \"qbinom\", \"rbinom\", \"dpois\",\n    \"ppois\", \"rpois\", \"dunif\", \"punif\", \"qunif\", \"runif\",\n    \"mean\", \"sd\", \"median\", \"quantile\", \"range\",\n    \"sum\", \"diff\", \"min\", \"max\", \"scale\",\n    \"c\", \"vector\", \"length\", \"matrix\"\n  )\n\n  check <- deparse(fct)\n\n  if ((check %in% allowed_fcts) == FALSE) {\n    return(\"Error\")\n  }\n\n  lapply(inp, get_ast)\n}\n","type":"text"},{"name":"correlation.R","content":"corrSidebarUI <- function(id) {\n    tabPanel(\n      \"Correlation\",\n      textInput(NS(id, \"dep\"), \"dependent Variable\", value = \"var1\"),\n      textInput(NS(id, \"indep\"), \"independent Variable\", value = \"var2\"),\n      actionButton(NS(id, \"pear\"), \"Pearson correlation\"),\n      actionButton(NS(id, \"spear\"), \"Spearman correlation\"),\n      actionButton(NS(id, \"kendall\"), \"Kendall correlation\"),\n      sliderInput(NS(id, \"conflevel\"), \"Confidence level of the interval\",\n                  min = 0, max = 1, value = 0.95),\n      selectInput(NS(id, \"alt\"), \"Alternative hypothesis\",\n                  c(\"Two sided\" = \"two.sided\",\n                    \"Less\" = \"less\",\n                    \"Greater\" = \"greater\"))\n    )\n}\n\ncorrUI <- function(id) {\n  fluidRow(\n        tags$head(\n          tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js\"),\n          tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js\"),\n          tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/html2canvas/0.4.1/html2canvas.min.js\"),\n          tags$script(src = \"download.js\")\n        ),\n        h4(strong(\"Results of test:\")),\n        tableOutput(NS(id, \"corr_result\")),\n        verbatimTextOutput(NS(id, \"corr_error\")),\n        actionButton(NS(id, \"corr_save\"), \"Add output to result-file\"),\n        actionButton(NS(id, \"download_corr\"), \"Save results\"),\n        checkboxGroupInput(NS(id, \"TableSaved\"), \"Saved results to file\", NULL)\n  )\n}\n\ncorrServer <- function(id, data, listResults) {\n  moduleServer(id, function(input, output, session) {  \n      corr_fct <- function(method) {\n        req(is.data.frame(data$df))\n        df <- data$df\n        req(input$dep)\n        req(input$indep)\n        dep <- input$dep\n        indep <- input$indep\n        d <- df\n        fit <- NULL\n        err <- NULL\n        e <- try(\n          fit <- broom::tidy(\n            cor.test(d[, dep], d[, indep],\n                     method = method,\n                     alternative = input$alt,\n                     conf.level = input$conflevel))\n        )\n        if (inherits(e, \"try-error\")) {\n          err <- conditionMessage(attr(e, \"condition\"))\n        } else {\n          listResults$curr_data <- fit\n          listResults$curr_name <- paste(\"Test Nr\", length(listResults$all_names) + 1, \"Conducted test: \", method)\n          output$corr_result <- renderTable(fit, digits = 6)\n          output$corr_error <- renderText(err)  \n        }\n      }\n      \n      observeEvent(input$pear, {\n        corr_fct(\"pearson\")\n      })\n      output$cor_result <- renderTable({\n        listResults$curr_data\n        }, digits = 6\n      )\n      \n      observeEvent(input$spear, {\n        corr_fct(\"spearman\")\n      })\n      output$cor_result <- renderTable({\n        listResults$curr_data\n        }, digits = 6\n      )\n      \n      observeEvent(input$kendall, {\n        corr_fct(\"kendall\")\n      })\n      output$cor_result <- renderTable({\n        listResults$curr_data\n        }, digits = 6\n      )\n      \n      observeEvent(input$corr_save, {\n        if (!(listResults$curr_name %in% unlist(listResults$all_names)) ) {\n          listResults$all_data[[length(listResults$all_data) + 1]] <- listResults$curr_data\n          listResults$all_names[[length(listResults$all_names) + 1]] <- listResults$curr_name  \n        }\n        updateCheckboxGroupInput(session, \"TableSaved\",\n                                 choices = listResults$all_names)\n      })\n      \n      observeEvent(input$download_corr, {\n        lr <- unlist(listResults$all_names)\n        indices <- sapply(input$TableSaved, function(x) {\n          which(x == lr)\n        })\n        req(length(indices) >= 1)\n        l <- listResults$all_data[indices]\n        jsString <- createJSString(l)\n        session$sendCustomMessage(type = \"downloadZip\",\n          list(numberOfResults = length(jsString),\n           FileContent = jsString))\n      })\n      \n\t})\n  \n  return(listResults)\n}\n\n\n\n\n\n","type":"text"},{"name":"plottingInternally.R","content":"annotateDF <- function(p, method, level = 2) {\n\tpB <- ggplot_build(p) # issue: otherwise data is empty\n\tdf <- pB$data[[1]]\t\n\tif (length(unique(df$PANEL)) > 1) {\n\t\tl <- pB$layout$layout\n\t\tl <- data.frame(PANEL = l$PANEL, names = l$`<unknown>`)\n\t\tdf$PANEL <- l[match(df$PANEL, l$PANEL), 2]\t\n\t}\n\t\t# https://stackoverflow.com/questions/40854225/how-to-identify-the-function-used-by-geom-smooth\n\tformula <- p$layers[[level]]$stat$setup_params(df, p$layers[[level]]$stat_params)$formula\n\tdf$interaction <- interaction(df$PANEL, df$group)\n\tresults <- lapply(unique(df$interaction), function(x) {\n\t\tsub <- df[df$interaction == x, ]\n\t\tcalcParams(sub, formula, method)\n\t})\n\tdf <- Reduce(rbind, results)\n\treturn(df)\n}\n\ncalcParams <- function(df, formula, method) {\n\tif (method == \"lm\") {\n\t\tmodel <- lm(formula, data = df)\n\t\tr_squared <- summary(model)$r.squared\n\t\tanova_table <- anova(model)\n\t\tf_value <- anova_table$`F value`[1]\n\t\tcoefficients <- coef(model)\n\t\tequation <- paste(\"Y =\", round(coefficients[1], 2), \"+\", \n\t\t\tround(coefficients[2], 2), \"* X\")\n\t\tp_value <- summary(model)$coefficients[ ,4] \n\t\tp_value <- paste(p_value, collapse = \" \")\n\t\tn <- nrow(df)\n\t\tannotations <- paste(\"R-squared:\", round(r_squared, 2),\n\t\t\t\"F-value:\", round(f_value, 2), \"\\n\",\n\t\t\t\"Equation:\", equation,\n\t\t\t\"Sample Size (n):\", n, \"\\n\",\n\t\t\t\"p-values Intercept & x:\", p_value )\n\t\tdf$annotation <- annotations\n\t\tdf$xPos <- mean(df$x)\n\t\tdf$yPos <- max(df$y)\n\t\treturn(df)\n\t} else if(method == \"glm\") {\n\t\tmodel <- glm(formula, data = df)\n\t\tr_squared <- with(summary(model), 1 - deviance/null.deviance)\n\t\tcoefficients <- coef(model)\n\t\tn <- nrow(df)\n\t\tequation <- paste(\"Y =\", round(coefficients[1], 2), \"+\", \n\t\t\tround(coefficients[2], 2), \"* X\")\n\t\tp_value <- summary(model)$coefficients[2,4] \n\t\tannotations <- paste(\"R-squared:\", round(r_squared, 2),\n\t\t\t\"Equation:\", equation,\n\t\t\t\"Sample Size (n):\", n, \"\\n\",\n\t\t\t\"p-value:\", round(p_value, 16) )\n\t\tdf$annotation <- annotations\n\t\tdf$xPos <- mean(df$x)\n\t\tdf$yPos <- max(df$y)\n\t\treturn(df)\n\t} else if(method == \"gam\") {\n\t\tmodel <- gam(formula, data = df)\n\t\tr_squared <- summary(model)$r.sq\n\t\tf_value <- summary(model)$p.t\n\t\tcoefficients <- coef(model)\n\t\tn <- nrow(df)\n\t\tequation <- paste(\"Y =\", round(coefficients[1], 2), \"+\", \n\t\t\tround(coefficients[2], 2), \"* X\")\n\t\tp_value <- summary(model)$p.pv\n\t\tannotations <- paste(\"R-squared:\", round(r_squared, 2),\n\t\t\t\"F-value:\", round(f_value, 2), \"\\n\",\n\t\t\t\"Equation:\", equation,\n\t\t\t\"Sample Size (n):\", n, \"\\n\",\n\t\t\t\"p-value:\", round(p_value, 16) )\n\t\tdf$annotation <- annotations\n\t\tdf$xPos <- mean(df$x)\n\t\tdf$yPos <- max(df$y)\n\t\treturn(df)\n\t} else if(method == \"loess\") {\n\t\tmodel <- loess(formula, data = df)\n\t\tfitted_values <- predict(model)\n\t\tr_squared <- cor(df$y, fitted_values)^2\n\t\tn <- nrow(df)\n\t\tannotations <- paste(\"R-squared:\", round(r_squared, 2),\n\t\t\t\"Sample Size (n):\", n)\n\t\tdf$annotation <- annotations\n\t\tdf$xPos <- mean(df$x)\n\t\tdf$yPos <- max(df$y)\n\t\treturn(df)\n\t}\n}\n\naddFacet <- function(p, facetVar, facetMode) {\n\tif(facetMode == \"facet_wrap\") {\n\t\treturn(p + facet_wrap(.~ .data[[facetVar]], scales = \"free\"))\n\t} else if(facetMode == \"facet_grid\") {\n\t\treturn(p + facet_grid(.~ .data[[facetVar]], scales = \"free\") )\n\t}\n}\n\nDotplotFct <- function(df, x, y, xLabel, yLabel,\n\tfitMethod,\n\tcolourVar, legendTitleColour,\n\tcolourTheme, facetMode, facetVar, k = 10) {\n\taes <- aes(x = .data[[x]], y = .data[[y]])\n\taesColour = NULL\n\taesFill = NULL\n\tp <- NULL\n\t\n\tif (colourVar == \"\") {\n\t\taesColour <- aes()\n\t} else {\n\t\taesColour <- aes(colour = .data[[colourVar]])\t\n\t}\n\tp <- ggplot(data = df,\n\t\taes(!!!aes, !!!aesColour)) +\n\tgeom_point() \n\n\tp <- p + xlab(xLabel)\n\tp <- p + ylab(yLabel)\n\tp <- p + guides(colour = guide_legend(title = legendTitleColour))\n\tp <- p + scale_color_brewer(palette = colourTheme)\t\n\tif(facetMode != \"none\") {\n\t\tp <- addFacet(p, facetVar, facetMode)\t \n\t}\t\n\tif(fitMethod == \"none\" | fitMethod == \"\") {\n\t\treturn(p)\n\t} else {\n\t\tif(fitMethod == \"gam\") {\n\t\t\tp <- p + geom_smooth(method = fitMethod,\n\t\t\t\tformula = y ~ s(x, bs = \"cs\", k = k))\n\t\t} else {\n\t\t\tp <- p + geom_smooth(method = fitMethod)\t\n\t\t}\n\t\tdf <- annotateDF(p, fitMethod) \n\t\tnames(df) <- ifelse(names(df) == \"PANEL\", \"Panel\", names(df))\n\t\tif(fitMethod == \"gam\") {\n\t\t\tp <- ggplot(data = df, aes(x = x, y = y, colour = colour)) +\n\t\t\tgeom_point() +\n\t\t\tgeom_smooth(method = fitMethod,\n\t\t\t\tformula = y ~ s(x, bs = \"cs\", k = k)) +\n\t\t\tgeom_text(aes(x = xPos, y = yPos,\n\t\t\t\tlabel = annotation, size = 3),\n\t\t\tshow.legend = FALSE, position = position_dodge(width = .9))\t\n\t\t} else {\n\t\t\tp <- ggplot(data = df, aes(x = x, y = y, colour = colour)) +\n\t\t\tgeom_point() +\n\t\t\tgeom_smooth(method = fitMethod) +\n\t\t\tgeom_text(aes(x = xPos, y = yPos,\n\t\t\t\tlabel = annotation, size = 3),\n\t\t\tshow.legend = FALSE, position = position_dodge(width = .9))\t\n\t\t}\n\t\t\n\t\tp <- p + xlab(xLabel)\n\t\tp <- p + ylab(yLabel)\n\t\tp <- p + guides(colour = guide_legend(title = legendTitleColour))\n\t\tp <- p + scale_color_brewer(palette = colourTheme)\t\t\n\t\tif(facetMode != \"none\") {\n\t\t\tp <- addFacet(p, \"Panel\", facetMode)\t\n\t\t} \n\t}\t\n\t\n\treturn(p)\n}\n#DotplotFct(df = CO2, x = \"conc\", y = \"uptake\", xLabel = \"x lable\", yLabel = \"y label\",\n#\t\t\t\t\t fitMethod = \"lm\", colourVar = \"\", legendTitleColour = \"Title colour\", \n#\t\t\t\t\t colourTheme = \"PuOr\", facetMode = \"facet_wrap\", facetVar = \"Type\", k = 10)\n\nBoxplotFct <- function(df, x, y, xLabel, yLabel,\n\tfillVar, legendTitleFill, fillTheme, \n\tcolourVar, legendTitleColour,\n\tcolourTheme, facetMode, facetVar) {\n\n\taes <- aes(x = .data[[x]], y = .data[[y]])\n\taesColour = NULL\n\taesFill = NULL\n\tp <- NULL\n\tif (colourVar == \"\") {\n\t\taesColour <- aes()\n\t} else {\n\t\taesColour <- aes(colour = .data[[colourVar]])\t\n\t}\n\tif (fillVar == \"\") {\n\t\taesFill <- aes()\n\t} else {\n\t\taesFill <- aes(fill = .data[[fillVar]])\t\n\t}\n\tp <- ggplot() +\n\tgeom_boxplot(data = df,\n\t\taes(!!!aes, !!!aesColour, !!!aesFill,\n\t\t\tgroup = interaction(.data[[x]],\n\t\t\t\t!!!aesColour, !!!aesFill) ) )\t\n\tp <- p + xlab(xLabel)\n\tp <- p + ylab(yLabel)\n\tp <- p + guides(fill = guide_legend(title = legendTitleFill))\n\tp <- p + guides(colour = guide_legend(title = legendTitleColour))\n\tp <- p + scale_fill_brewer(palette = fillTheme)\t\n\tp <- p + scale_color_brewer(palette = colourTheme)\t\n\tif(facetMode != \"none\") {\n\t\tp <- addFacet(p, facetVar, facetMode)\t \n\t}\t\n\treturn(p)\n}\n\nLineplotFct <- function(df, x, y, xLabel, yLabel,\n\tcolourVar, legendTitleColour,\n\tcolourTheme, facetMode, facetVar) {\n\taes <- aes(x = .data[[x]], y = .data[[y]])\n\taesColour = NULL\n\tp <- NULL\n\tif (colourVar == \"\") {\n\t\taesColour <- aes()\n\t} else {\n\t\taesColour <- aes(colour = .data[[colourVar]])\t\n\t}\n\tp <- ggplot() +\n\tgeom_line(data = df,\n\t\taes(!!!aes, !!!aesColour, \n\t\t\tgroup = interaction(.data[[x]],\n\t\t\t\t!!!aesColour) ) )\t\n\tp <- p + xlab(xLabel)\n\tp <- p + ylab(yLabel)\n\tp <- p + guides(colour = guide_legend(title = legendTitleColour))\n\tp <- p + scale_color_brewer(palette = colourTheme)\t\n\tif(facetMode != \"none\") {\n\t\tp <- addFacet(p, facetVar, facetMode)\t \n\t}\t\n\treturn(p)\n}\n","type":"text"},{"name":"tests/test_plotting.R","content":"library(tinytest)\n\nmock_ggplot <- ggplot(data = CO2, aes(x = uptake, y = conc)) +\n                  geom_point() +\n                  geom_smooth()\ntest_annotateDF <- function() {\n  df <- annotateDF(mock_ggplot, method = \"lm\")\n  expect_equal(nrow(df), 84)\n  expect_equal(ncol(df), 14)  \n}\ntest_annotateDF()\n\ntest_calcParams <- function() {\n  df <- data.frame(x = 1:10, y = 1:10)\n  model <- calcParams(df, formula = y ~ x, method = \"lm\")\n  a <- model$annotation\n  r2 <- strsplit(a, split = \" \")[[1]][2]\n  expect_equal(r2, \"1\")\n}\ntest_calcParams()\n\ntest_dir()","type":"text"},{"name":"ummary(model)$r.squared","content":"vars                  package:ggplot2                  R Documentation\n\n_\bQ_\bu_\bo_\bt_\be _\bf_\ba_\bc_\be_\bt_\bi_\bn_\bg _\bv_\ba_\br_\bi_\ba_\bb_\bl_\be_\bs\n\n_\bD_\be_\bs_\bc_\br_\bi_\bp_\bt_\bi_\bo_\bn:\n\n     Just like ‘aes()’, ‘vars()’ is a quoting function that takes\n     inputs to be evaluated in the context of a dataset. These inputs\n     can be:\n\n        • variable names\n\n        • complex expressions\n\n     In both cases, the results (the vectors that the variable\n     represents or the results of the expressions) are used to form\n     faceting groups.\n\n_\bU_\bs_\ba_\bg_\be:\n\n     vars(...)\n     \n_\bA_\br_\bg_\bu_\bm_\be_\bn_\bt_\bs:\n\n     ...: <‘data-masking’> Variables or expressions automatically\n          quoted. These are evaluated in the context of the data to\n          form faceting groups. Can be named (the names are passed to a\n          labeller).\n\n_\bS_\be_\be _\bA_\bl_\bs_\bo:\n\n     ‘aes()’, ‘facet_wrap()’, ‘facet_grid()’\n\n_\bE_\bx_\ba_\bm_\bp_\bl_\be_\bs:\n\n     p <- ggplot(mtcars, aes(wt, disp)) + geom_point()\n     p + facet_wrap(vars(vs, am))\n     \n     # vars() makes it easy to pass variables from wrapper functions:\n     wrap_by <- function(...) {\n       facet_wrap(vars(...), labeller = label_both)\n     }\n     p + wrap_by(vs)\n     p + wrap_by(vs, am)\n     \n     # You can also supply expressions to vars(). In this case it's often a\n     # good idea to supply a name as well:\n     p + wrap_by(drat = cut_number(drat, 3))\n     \n     # Let's create another function for cutting and wrapping a\n     # variable. This time it will take a named argument instead of dots,\n     # so we'll have to use the \"enquote and unquote\" pattern:\n     wrap_cut <- function(var, n = 3) {\n       # Let's enquote the named argument `var` to make it auto-quoting:\n       var <- enquo(var)\n     \n       # `as_label()` will create a nice default name:\n       nm <- as_label(var)\n     \n       # Now let's unquote everything at the right place. Note that we also\n       # unquote `n` just in case the data frame has a column named\n       # `n`. The latter would have precedence over our local variable\n       # because the data is always masking the environment.\n       wrap_by(!!nm := cut_number(!!var, !!n))\n     }\n     \n     # Thanks to tidy eval idioms we now have another useful wrapper:\n     p + wrap_cut(drat)\n     \n\n","type":"text"},{"name":"utils.R","content":"DF2String <- function(df) {\n\tresNames <- names(df)\n\tresNames <- paste(resNames, collapse = \"\\t\")\n\tresNames <- paste(resNames, \"\\n\")\n\tres <- apply(df, 1, function(x) {\n\t\tx <- as.character(x)\n\t\tx <- paste(x, collapse = \"\\t\")\n\t\treturn(x)\n\t})\n\tres <- paste0(resNames, \"\\n\", res, collapse = \"\")\n\tres <- paste0(res, \"\\n\")\n}\n\nsetClass(\"plot\", \n  slots = c(\n    p = \"ANY\", \n    width = \"numeric\",\n    height = \"numeric\",\n    resolution = \"numeric\"\n  )\n)\n\ncreateJSString <- function(l) {\n\tjsString <- character(length(l))\n\tfor (i in seq_along(l)) {\n        if (inherits(l[[i]], \"plot\")) {\n          p <- l[[i]]@p\n          width <- l[[i]]@width\n          height <- l[[i]]@height\n          resolution <- l[[i]]@resolution\n          fn <- tempfile(fileext = '.png')\n          ggsave(plot = p, filename = fn, width = width, height = height, dpi = resolution) \n          jsString[i] <- paste0(\"data:image/png;base64,\", base64enc::base64encode(fn))\n          unlink(fn)\n        } else if (inherits(l[[i]], \"data.frame\")) {\n          jsString[i] <- DF2String(l[[i]])\n        } else if (is.character(l[[i]])) {\n          jsString[i] <- l[[i]]\n        }\n  }\n  return(jsString)\n}","type":"text"},{"name":"visualisation.R","content":"visSidebarUI <- function(id) {\n  tabPanel(\n    \"Visualisation\",\n    textInput(NS(id , \"yVar\"), \"Y variable\", value = \"y\"),\n    textInput(NS(id, \"xVar\"), \"X variable\", value = \"x\"),\n    radioButtons(NS(id, \"xType\"), \"Type of x\",\n                 choices = c(\n                   factor = \"factor\",\n                   numeric = \"numeric\"\n                 ),\n                 selected = \"factor\"\n    ),\n    textInput(NS(id, \"xaxisText\"), \"X axis label\", value = \"x label\"),\n    textInput(NS(id, \"yaxisText\"), \"Y axis label\", value = \"y label\"),\n    conditionalPanel(\n        condition = \"input.VisConditionedPanels == 'Scatterplot'\",\n        selectInput(NS(id, \"fitMethod\"), \"Choose a fitting method\",\n                    c(\n                      \"none\" = \"none\",\n                      \"lm\" = \"lm\",\n                      \"glm\" = \"glm\",\n                      \"gam\" = \"gam\",\n                      \"loess\" = \"loess\"\n                    ),\n                    selectize = FALSE\n        ),\n        numericInput(NS(id, \"k\"), \"number of knots used by spline for gam\", value = 10)\n    ),\n    conditionalPanel(\n      condition = \"input.VisConditionedPanels == 'Boxplot'\",\n      textInput(NS(id, \"fill\"), \"Fill variable\"),\n      textInput(NS(id, \"legendTitleFill\"), \"Legend title for fill\", value = \"Title fill\"),\n      selectInput(NS(id, \"themeFill\"), \"Choose a 'fill' theme\",\n                c(\n                  \"BuGn\" = \"BuGn\",\n                  \"PuRd\" = \"PuRd\",\n                  \"YlOrBr\" = \"YlOrBr\",\n                  \"Greens\" = \"Greens\",\n                  \"GnBu\" = \"GnBu\",\n                  \"Reds\" = \"Reds\",\n                  \"Oranges\" = \"Oranges\",\n                  \"Greys\" = \"Greys\"\n                ),\n                selectize = FALSE\n      )\n    ),\n    textInput(NS(id, \"col\"), \"Colour variable\"),\n    textInput(NS(id, \"legendTitleCol\"), \"Legend title for colour\", value = \"Title colour\"),\n    selectInput(NS(id, \"theme\"), \"Choose a 'colour' theme\",\n                c(\n                  \"Accent\" = \"Accent\",\n                  \"Dark2\" = \"Dark2\",\n                  \"Paired\" = \"Paired\",\n                  \"Pastel1\" = \"Pastel1\",\n                  \"Pastel2\" = \"Pastel2\",\n                  \"Set1\" = \"Set1\",\n                  \"Set2\" = \"Set2\",\n                  \"Set3\" = \"Set3\"\n                ),\n                selectize = FALSE\n    ),\n    radioButtons(NS(id, \"facetMode\"),\n                 \"Choose Facet Mode:\",\n                 choices = c(\"none\", \"facet_wrap\", \"facet_grid\")\n    ),\n    textInput(NS(id, \"facetBy\"), \"split plot by\")\n    )\n}\n\nvisUI <- function(id) {\n  fluidRow(\n    tags$head(\n      tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js\"),\n      tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js\"),\n      tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/html2canvas/0.4.1/html2canvas.min.js\"),\n      tags$script(src = \"download.js\")\n    ),\n    br(),\n    tabsetPanel(\n      tabPanel(\"Boxplot\",\n          br(),\n          actionButton(NS(id, \"CreatePlotBox\"), \"Create plot\")\n      ),\n      tabPanel(\"Scatterplot\",\n          br(),\n          actionButton(NS(id, \"CreatePlotScatter\"), \"Create plot\") \n      ),\n      tabPanel(\"Lineplot\",\n          br(),\n          actionButton(NS(id, \"CreatePlotLine\"), \"Create plot\")\n      ),\n      id = \"VisConditionedPanels\"   \n    ),\n    plotOutput(NS(id, \"plotResult\")),\n    actionButton(NS(id, \"plotSave\"), \"Add output to result-file\"),\n    checkboxGroupInput(NS(id, \"TableSaved\"), \"Saved results to file\", NULL),\n    fluidRow(\n      column(4,\n        numericInput(NS(id, \"widthPlot\"), \"Width of plot [cm]\", value = 10)\n      ),\n      column(4,\n        numericInput(NS(id, \"heightPlot\"), \"Height of plot [cm]\", value = 10)\n      ),\n      column(4,\n        numericInput(NS(id, \"resPlot\"), \"Resolution of plot\", value = 300)\n      ),\n    ),\n    fluidRow(\n      column(12,\n        actionButton(NS(id, \"downloadViss\"), \"Save results\")\n      )\n    )\n  )\n}\n\nvisServer <- function(id, data, listResults) {\n  moduleServer(id, function(input, output, session) {  \n    \n    plotFct <- function(method) {\n      req(is.data.frame(data$df))\n      df <- data$df\n      req(input$yVar)\n      req(input$xVar)\n      x <- input$xVar; y <- input$yVar\n      colNames <- names(df)\n      checkX <- x %in% colNames\n      checkY <- y %in% colNames\n      if (!checkX) showNotification(\"X variable not found\", duration = 0)\n      if (!checkY) showNotification(\"Y variable not found\", duration = 0) \n      req(checkX)\n      req(checkY)\n      width <- input$widthPlot\n      height <- input$heightPlot\n      resolution <- input$resPlot\n      if (width <= 0) {\n        showNotification(paste(\"width has to be a positive number is changed to 10 cm\"), duration = 0)\n        width <- 10\n      }\n      if (height <= 0) {\n        showNotification(paste(\"height has to be a positive number is changed to 10 cm\"), duration = 0)\n        height <- 10\n      }\n      if (width > 100) {\n        showNotification(paste(\"width exceeds max value of 100 cm. Is set to 100 cm.\"), duration = 0)\n        width <- 100\n      }\n      if (height > 100) {\n        showNotification(paste(\"height exceeds max value of 100 cm. Is set to 100 cm.\"), duration = 0)\n        height <- 100\n      }\n      col <- input$col\n      fill <- input$fill\n      if ( !(fill %in% names(df)) && (fill != \"\") ) showNotification(\"fill variable not found\", duration = 0)\n      if ( !(col %in% names(df)) && (col != \"\") ) showNotification(\"colour variable not found\", duration = 0)\n      req( (fill %in% names(df)) || (fill == \"\") )\n      req( (col %in% names(df)) || (col == \"\") )\n      fillTitle <- input$legendTitleFill\n      colTitle <- input$legendTitleCol\n      xlabel <- input$xaxisText\n      ylabel <- input$yaxisText\n      xtype <- input$xType\n      theme <- input$theme\n      themeFill <- input$themeFill\n      facetMode <- input$facetMode\n      facet <- input$facetBy\n      fitMethod <- input$fitMethod\n      \n      xd <- NULL\n      if (xtype == \"numeric\") {\n        xd <- as.numeric(df[,x])\n      } else {\n        xd <- as.factor(df[,x])\n      }\n      yd <- as.numeric(df[,y])\n      if (fitMethod != \"none\" && !is.null(fitMethod) && xtype != \"numeric\") {\n        showNotification(\"Fit method will be ignored as X variable is not numerical\", duration = 0)\n        fitMethod <- \"none\"\n      }\n\n      p <- tryCatch({\n        if (method == \"box\") {\n          p <- BoxplotFct(df, x, y, xlabel, ylabel,\n                    fill, fillTitle, themeFill,\n                    col, colTitle, theme, \n                    facetMode, facet)\n        } else if (method == \"dot\") {\n          k <- NULL\n          if (fitMethod == \"gam\") {\n            req(input$k)\n            k <- input$k\n            if(k <= 0) {\n              showNotification(\"k has to be at least 1 and is set to this value\")\n              k <- 1\n            }\n          }\n          p <- DotplotFct(df, x, y, xlabel, ylabel,\n                    fitMethod,\n                    col, colTitle, theme,\n                    facetMode, facet, k)\n        } else if (method == \"line\") {\n          p <- LineplotFct(df, x, y, xlabel, ylabel,\n                    col, colTitle, theme,\n                     facetMode, facet)\n        }\n      }, \n      warning = function(warn) {\n        showNotification(paste(\"A warning occurred: \", conditionMessage(warn)), duration = 0)\n      }, \n      error = function(err) {\n        showNotification(paste(\"An error occurred: \", conditionMessage(err)), duration = 0)\n      })\n      output$plotResult <- renderPlot(p)\n      listResults$curr_data <- new(\"plot\", p = p, width = width, height = height, resolution = resolution)\n      listResults$curr_name <- paste(\"Plot Nr\",\n                                     length(listResults$all_names) + 1,  paste(\"Type: \", method))\n    }\n    \n    observeEvent(input$CreatePlotBox, {\n      req(is.data.frame(data$df))\n      plotFct(\"box\")\n    })\n    output$plotResult <- renderPlot({\n      renderPlot(listResults$curr_data)\n    })\n    \n    observeEvent(input$CreatePlotScatter, {\n      req(is.data.frame(data$df))\n      plotFct(\"dot\")\n    })\n    output$plotResult <- renderPlot({\n      renderPlot(listResults$curr_data)\n    })\n    \n    observeEvent(input$CreatePlotLine, {\n      req(is.data.frame(data$df))\n      plotFct(\"line\")\n    })\n    output$plotResult <- renderPlot({\n      renderPlot(listResults$curr_data)\n    })\n    \n    observeEvent(input$plotSave, {\n      if (!(listResults$curr_name %in% unlist(listResults$all_names)) ) {\n        listResults$all_data[[length(listResults$all_data) + 1]] <- listResults$curr_data\n        listResults$all_names[[length(listResults$all_names) + 1]] <- listResults$curr_name  \n      }\n      updateCheckboxGroupInput(session, \"TableSaved\",\n                               choices = listResults$all_names)\n    })\n    \n    observeEvent(input$downloadViss, {\n      lr <- unlist(listResults$all_names)\n      indices <- sapply(input$TableSaved, function(x) {\n        which(x == lr)\n      })\n      req(length(indices) >= 1)\n      l <- listResults$all_data[indices]\n      jsString <- createJSString(l)\n      session$sendCustomMessage(type = \"downloadZip\",\n                                list(numberOfResults = length(jsString),\n                                     FileContent = jsString))\n    })\n    \n    \n  })\n}\n","type":"text"},{"name":"www/download.js","content":"Shiny.addCustomMessageHandler('downloadZip', function(message) {\n  var FileContent = message.FileContent;\n  if( (typeof FileContent) == \"string\") {\n    if (FileContent.startsWith(\"data:image\")) {\n      var fileName = 'file' + (i + 1) + '.png'; \n      var zip = new JSZip();\n      var imageData = atob(FileContent.split(',')[1]);\n      var byteArray = new Uint8Array(imageData.length);\n      for (var i = 0; i < imageData.length; i++) {\n        byteArray[i] = imageData.charCodeAt(i);\n      }\n      zip.file(fileName, byteArray, {binary: true});\n      zip.generateAsync({type: 'blob'}).then(function(content) {\n        saveAs(content, 'download.zip');\n      });\n    } else {\n      var zipText = new JSZip();\n      var fileNameText = 'file' + 1 + '.txt'; \n      zipText.file(fileNameText, FileContent);\n      zipText.generateAsync({type: 'blob'}).then(function(content) {\n        saveAs(content, 'download.zip');\n      });\n    }\n  } else {\n    var zip = new JSZip();\n    for (var i in FileContent) {\n      if (FileContent[i].startsWith(\"data:image\")) {\n        var fileName = 'file' + (i + 1) + '.png'; \n        var imageData = atob(FileContent[i].split(',')[1]);\n        var byteArray = new Uint8Array(imageData.length);\n        for (var i = 0; i < imageData.length; i++) {\n          byteArray[i] = imageData.charCodeAt(i);\n        }\n        zip.file(fileName, byteArray, {binary: true});\n      } else {\n        var fileName = 'file' + (i + 1) + '.txt'; \n        zip.file(fileName, FileContent[i]); \n      }\n    }\n    zip.generateAsync({type: 'blob'}).then(function(content) {\n      saveAs(content, 'download.zip');\n    });\n  }\n});","type":"text"}]
